#' Summary function for ADMerge analysis results
#'
#' This function generates a summary of the results from the ADMerge function, including the number of participants, number of variables, and the merging parameters.
#'
#' @param res The result object from the ADMerge function.
#' @param vars A vector of variable names to include in the summary. If NULL, all variables will be included.
#' @param ... Additional parameters for the function.
#'
#' @return A summary of the ADMerge analysis results.
#' @export
#'
#' @import ggplot2
#' 
#'
#' @examples
#' \dontrun{
#' summary.ADMerge_res(res)
#' }
#'
#'
summary.ADMerge_res = function(res, vars = NULL, ...) {
  ana_data = res$analysis_data
  dict_src = res$dict_src
  name_ID = na.omit(unique(unlist(strsplit(dict_src$ID_for_merge, ", "))))[1]
  pat = ana_data %>% distinct(ID_merged, .keep_all = TRUE)
  n_pat = dim(pat)[1]
  n_var = dim(pat)[2]
  win_setting = dict_src %>%
    select(c(file, WINDOW, IS_overlap)) %>%
    mutate(info = paste(file, WINDOW, IS_overlap)) %>%
    pull(info)
  win_setting = c("File Window_Size Is_Overlap", win_setting)
  cat('Number of participants:', n_pat,
      'Number of variables:',    n_var,
      'Merged by:',              name_ID,
      'Window settings:',        win_setting,
      sep = "\n")
}

#' Plot function for ADMerge analysis results
#'
#' This function generates a bar plot of the distribution of a given variable among different groups in the merged dataset generated by the ADMerge function.
#'
#' @param res The result object from the ADMerge function.
#' @param distn The name of the variable to plot the distribution of.
#' @param group The name of the variable to group the distribution by.
#' @param baseline A boolean indicating whether to include only the baseline data in the plot.
#' @param ... Additional parameters for the function.
#'
#' @return A bar plot of the distribution of the given variable among different groups in the merged dataset.
#' @export
#'
#' @examples
#' \dinttun{
#' plot.ADMerge_res(res, "AGE", "SEX")
#' }
#'
#' @import ggplot2
#'
plot.ADMerge_res = function(res,
                            distn, # extend ...
                            group,
                            baseline = TRUE,
                            ...) {
  ana_data = res$analysis_data
  dict_src = res$dict_src
  name_ID = na.omit(unique(unlist(strsplit(dict_src$ID_for_merge, ", "))))[1]
  plot_data <- ana_data %>%
    select(ID_merged, !!as.name(distn), !!as.name(group)) %>% 
    mutate(!!as.name(group) := factor(!!as.name(group)))
  if (baseline) {
    plot_data <- plot_data %>%
      distinct(ID_merged, .keep_all = TRUE)
  }
  a_gen_tbl <- function(pat, group, distn) {
    info <- as.data.frame(pat %>%
                            count(!!as.name(distn), !!as.name(group))) %>%
      na.omit()
    tbl <- reshape(info, idvar = distn, timevar = group, direction = 'wide', sep = '_') %>%
      replace(., is.na(.), 0) %>%
      mutate(All = rowSums(across(where(is.numeric))))
    return(tbl)
  }
  tbl <- a_gen_tbl(plot_data, group, distn)
  p <- ggplot(plot_data) +
    theme_bw() +
    geom_bar(aes(x = !!as.name(distn), color = !!as.name(group), fill = !!as.name(group)),
             position = 'stack', alpha = 0.9) +
    labs(x = distn, y = 'Number of Subjects', title = 'Participant Distribution') +
    theme(plot.title = element_text(size = 12, face = 'bold', hjust = 0.5))
  p
}



#' Plot function for files used to merge
#'
#' This function generates a scatter plot for distribution of IDs across time, grouped by different files
#'
#' @param scr_table The source table generated from the function.
#' @param path The path of the folder data located 
#' @param ... Additional parameters for the function.
#'
#' @return A bar plot of the distribution of the given variable among different groups in the merged dataset.
#' @export
#'
#' @examples
#' \dinttun{
#' plot.ADMerge_res(path,scr_table)
#' }
#'
#' @import ggplot2
#' @import plotly
#' @import htmlwidgets
#' @import lubridate
#' 
#' @import tidyr
#' 
#' @import data.table
#' 


# plot.files_no_dropdown <- function(path, FILE_pattern = "\\.xlsx$|\\.xls$|\\.csv$", dict_src = NULL) {
#   files_list <- list.files(path, pattern = FILE_pattern)
#   
#   # Load each file into the global environment
#   for (file_name in files_list) {
#     dat <- suppressWarnings(read_by_type(file_name, path))
#     f_name <- gsub(FILE_pattern, "", file_name) # Clean file name
#     assign(f_name, dat, envir = .GlobalEnv)
#   }
#   
#   # Initialize an empty dataframe for the results
#   combined_data <- data.frame(ID = character(), DATE = character(), FILE = character())
#   
#   dat_list <- dict_src$file
#   
#   for (data in dat_list) {
#     idx <- grep(data, dict_src$file)
#     if (length(idx) > 0) {
#       ID_col <- dict_src$ID_for_merge[idx]
#       DATE_col <- dict_src$DATE_for_merge[idx]
#       
#       dat_name <- gsub(FILE_pattern, "", data)
#       dat_tem <- get(dat_name, envir = .GlobalEnv)
#       
#       if (ID_col %in% names(dat_tem) && DATE_col %in% names(dat_tem)) {
#         dat_tem <- dat_tem %>%
#           mutate(!!as.name(ID_col) := as.character(.[[ID_col]]),
#                  !!as.name(DATE_col) := case_when(
#                    stringr::str_detect(.[[DATE_col]], "\\d{1,2}/\\d{1,2}/\\d{4}") ~ dmy(.[[DATE_col]], quiet = TRUE),
#                    stringr::str_detect(.[[DATE_col]], "\\d{4}-\\d{1,2}-\\d{1,2}") ~ ymd(.[[DATE_col]], quiet = TRUE),
#                    TRUE ~ as.Date(NA)
#                  ),
#                  FILE = as.character(data)) %>%
#           select(ID = !!as.name(ID_col), DATE = !!as.name(DATE_col), FILE)
#         
#         # Combine with the previously collected data
#         combined_data <- rbind(combined_data, dat_tem)
#       }
#     }
#   }
#   
#   # Start plotting
#   
#   combined_data$DATE <- as.Date(combined_data$DATE)
#   
#   combined_data <- combined_data %>% mutate(color = as.factor(FILE))
#   
#   color_palette <- RColorBrewer::brewer.pal(length(unique(combined_data$color)), "Set1")
#   
#   color_map <- setNames(color_palette, levels(combined_data$color))
#   
#   combined_data <- combined_data %>% mutate(color_value = color_map[color])
#   
#   combined_data <- combined_data %>% mutate(hover_text = paste("File:", FILE))
#   
#   p <- plot_ly(data = combined_data, x = ~DATE, y = ~ID, type = 'scattergl', mode = 'markers',
#                hoverinfo = 'text', # Display the hover text when hovering
#                text = ~hover_text, # Set the text that appears on hover
#                marker = list(size = 10, opacity = 0.6, color = ~color_value))
#   
#   # Add a custom hover event to highlight the group (FILE)
#   p <- p %>% onRender("
# function(el) {
#   var plotlyGraph = document.getElementById(el.id);
#   
#   plotlyGraph.on('plotly_hover', function(data) {
#     // Find the index of the hovered data point
#     var hoverIndex = data.points[0].pointIndex;
#     console.log('Hover index data:', hoverIndex);
#     
#     // Get the trace and group information for the hovered data point
#     var traceIndex = data.points[0].curveNumber;
#     var groupValue = data.points[0].fullData.marker.color[hoverIndex];
#     console.log('groupValue:', groupValue);
#     
#     // Create an array to set opacities
#     var opacities = new Array(data.points[0].fullData.x.length).fill(0.1); // Start with all opacities at 0.1
#     
#     // Set the opacity of the points in the same group as the hovered point to 1 (highlight)
#     data.points[0].fullData.x.forEach(function(_, i) {
#       if(data.points[0].fullData.marker.color[i] === groupValue) {
#         opacities[i] = 1;
#       }
#     });
#     
#     // Restyle the plot with the updated opacities
#     Plotly.restyle(el.id, {'marker.opacity': [opacities]}, [traceIndex]);
#   });
#   
#   plotlyGraph.on('plotly_unhover', function(data) {
#     // Reset the opacity for all points when not hovering
#     var resetOpacities = new Array(data.points[0].fullData.x.length).fill(0.1); // Reset all opacities to 0.6
#     Plotly.restyle(el.id, {'marker.opacity': [resetOpacities]});
#   });
# }
# ")
#   
#   # Customize the layout if desired
#   p <- p %>% layout(title = 'ID over Time by File',
#                     xaxis = list(title = 'Time'),
#                     yaxis = list(title = 'ID'),
#                     legend = list(orientation = 'h', x = 0, y = -0.3, xanchor = 'left', yanchor = 'bottom'),
#                     hovermode = 'closest')
#   
#   
#   
#   return(p)
#   
# 
# }


plot.files <- function(path, FILE_pattern = "\\.xlsx$|\\.xls$|\\.csv$", dict_src = NULL) {
  files_list <- list.files(path, pattern = FILE_pattern)
  
  # Load each file into the global environment
  for (file_name in files_list) {
    dat <- suppressWarnings(read_by_type(file_name, path))
    f_name <- gsub(FILE_pattern, "", file_name) # Clean file name
    assign(f_name, dat, envir = .GlobalEnv)
  }
  
  # Initialize an empty dataframe for the results
  combined_data <- data.frame(ID = character(), DATE = character(), FILE = character())
  
  dat_list <- dict_src$file
  
  for (data in dat_list) {
    idx <- grep(data, dict_src$file)
    if (length(idx) > 0) {
      ID_col <- dict_src$ID_for_merge[idx]
      DATE_col <- dict_src$DATE_for_merge[idx]
      
      dat_name <- gsub(FILE_pattern, "", data)
      dat_tem <- get(dat_name, envir = .GlobalEnv)
      
      if (ID_col %in% names(dat_tem) && DATE_col %in% names(dat_tem)) {
        dat_tem <- dat_tem %>%
          mutate(!!as.name(ID_col) := as.character(.[[ID_col]]),
                 !!as.name(DATE_col) := case_when(
                   stringr::str_detect(.[[DATE_col]], "\\d{1,2}/\\d{1,2}/\\d{4}") ~ dmy(.[[DATE_col]], quiet = TRUE),
                   stringr::str_detect(.[[DATE_col]], "\\d{4}-\\d{1,2}-\\d{1,2}") ~ ymd(.[[DATE_col]], quiet = TRUE),
                   TRUE ~ as.Date(NA)
                 ),
                 FILE = as.character(data)) %>%
          select(ID = !!as.name(ID_col), DATE = !!as.name(DATE_col), FILE)
        
        # Combine with the previously collected data
        combined_data <- rbind(combined_data, dat_tem)
      }
    }
  }
  
  # Start plotting
  
  combined_data$DATE <- as.Date(combined_data$DATE)
  
  combined_data <- combined_data %>% distinct() %>%
    drop_na()
  
  combined_data <- combined_data %>% mutate(color = as.factor(FILE))
  
  color_palette <- RColorBrewer::brewer.pal(length(unique(combined_data$color)), "Set1")
  
  color_map <- setNames(color_palette, levels(combined_data$color))
  
  combined_data <- combined_data %>% mutate(color_value = color_map[color])
  
  combined_data <- combined_data %>% mutate(hover_text = paste("File:", FILE))
  
  setDT(combined_data)
  
  
  # p <- plot_ly(data = combined_data, x = ~DATE, y = ~ID, type = 'scatter', mode = 'markers',
  #              hoverinfo = 'text', # Display the hover text when hovering
  #              text = ~hover_text, # Set the text that appears on hover
  #              marker = list(size = 10, opacity = 0.6, color = ~color_value))
  
  unique_types <- unique(combined_data$FILE)
  
  fig <- plot_ly()
  
  
  for (type in unique_types) {
    fig <- fig %>% add_trace(
      data = combined_data[combined_data$FILE == type, ],
      x = ~DATE,
      y = ~ID,
      hoverinfo ="text",
      name = type,
      type = 'scattergl',
      text = ~hover_text,
      mode = 'markers',
      visible = TRUE,
      marker = list(size = 10, opacity = 0.6, color = ~color_value)# Set visible to TRUE
    )
  }
  
  # Generate dropdown items based on unique types
  buttons <- lapply(seq_along(unique_types), function(i) {
    list(
      method = "restyle",
      args = list("visible", lapply(seq_along(unique_types), function(j) i == j)),
      label = unique_types[i]
    )
  })
  
  # Add an "All" button to the dropdown
  all_button <- list(
    method = "restyle",
    args = list("visible", rep(TRUE, length(unique_types))),
    label = "All"
  )
  
  # Ensure "All" is the first button, making it the default selection
  buttons <- c(list(all_button), buttons)
  
  fig <- fig %>% layout(
    title = NULL,
    xaxis = list(title = "TIME"),
    yaxis = list(title = "ID"),
    showlegend = FALSE, 
    updatemenus = list(
      list(
        buttons = buttons,
        direction = "down",
        showlegend = FALSE,
        pad = list(r = 10, t = 10),
        showactive = TRUE,
        x = 0.1,
        xanchor = "left",
        y = 1.1,
        yanchor = "top"
      )
    )
  )
  
  # Add a custom hover event to highlight the group (FILE)
  js_code <-  "
function(el) {
  var plotlyGraph = document.getElementById(el.id);
  
  plotlyGraph.on('plotly_hover', function(data) {
    // Find the index of the hovered data point
    var hoverIndex = data.points[0].pointIndex;
    console.log('Hover index data:', hoverIndex);
    
    // Get the trace and group information for the hovered data point
    var traceIndex = data.points[0].curveNumber;
    var groupValue = data.points[0].fullData.marker.color[hoverIndex];
    console.log('groupValue:', groupValue);
    
    // Create an array to set opacities
    var opacities = new Array(data.points[0].fullData.x.length).fill(0.1); // Start with all opacities at 0.1
    
    // Set the opacity of the points in the same group as the hovered point to 1 (highlight)
    data.points[0].fullData.x.forEach(function(_, i) {
      if(data.points[0].fullData.marker.color[i] === groupValue) {
        opacities[i] = 1.5;
      }
    });
    
    // Restyle the plot with the updated opacities
    Plotly.restyle(el.id, {'marker.opacity': [opacities]}, [traceIndex]);
  });
  
  plotlyGraph.on('plotly_unhover', function(data) {
    // Reset the opacity for all points when not hovering
    var resetOpacities = new Array(data.points[0].fullData.x.length).fill(0.1); // Reset all opacities to 0.1
    Plotly.restyle(el.id, {'marker.opacity': [resetOpacities]});
  });
}
"

# Customize the layout if desired


fig <- fig %>% onRender(js_code)



return(fig)
}





