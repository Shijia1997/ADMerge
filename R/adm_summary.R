#' Summary function for ADMerge analysis results
#'
#' This function generates a summary of the results from the ADMerge function, including the number of participants, number of variables, and the merging parameters.
#'
#' @param res The result object from the ADMerge function.
#' @param vars A vector of variable names to include in the summary. If NULL, all variables will be included.
#' @param ... Additional parameters for the function.
#'
#' @return A summary of the ADMerge analysis results.
#' @export
#'
#' @import ggplot2
#' 
#'
#' @examples
#' \dontrun{
#' summary.ADMerge_res(res)
#' }
#'
#'
summary.ADMerge_res = function(res, vars = NULL, ...) {
  ana_data = res$analysis_data
  dict_src = res$dict_src
  name_ID = na.omit(unique(unlist(strsplit(dict_src$ID_for_merge, ", "))))[1]
  pat = ana_data %>% distinct(ID_merged, .keep_all = TRUE)
  n_pat = dim(pat)[1]
  n_var = dim(pat)[2]
  win_setting = dict_src %>%
    select(c(file, WINDOW, IS_overlap)) %>%
    mutate(info = paste(file, WINDOW, IS_overlap)) %>%
    pull(info)
  win_setting = c("File Window_Size Is_Overlap", win_setting)
  cat('Number of participants:', n_pat,
      'Number of variables:',    n_var,
      'Merged by:',              name_ID,
      'Window settings:',        win_setting,
      sep = "\n")
}

#' Plot function for ADMerge analysis results
#'
#' This function generates a bar plot of the distribution of a given variable among different groups in the merged dataset generated by the ADMerge function.
#'
#' @param res The result object from the ADMerge function.
#' @param distn The name of the variable to plot the distribution of.
#' @param group The name of the variable to group the distribution by.
#' @param baseline A boolean indicating whether to include only the baseline data in the plot.
#' @param ... Additional parameters for the function.
#'
#' @return A bar plot of the distribution of the given variable among different groups in the merged dataset.
#' @export
#'
#' @examples
#' \dinttun{
#' plot.ADMerge_res(res, "AGE", "SEX")
#' }
#'
#' @import ggplot2
#'
plot.ADMerge_res = function(res,
                            distn, # extend ...
                            group,
                            baseline = FALSE,
                            ...) {
  ana_data = res$analysis_data
  dict_src = res$dict_src
  name_ID = na.omit(unique(unlist(strsplit(dict_src$ID_for_merge, ", "))))[1]
  plot_data <- ana_data %>%
    select(ID_merged, !!as.name(distn), !!as.name(group)) %>% 
    mutate(!!as.name(group) := factor(!!as.name(group)))
  if (baseline) {
    plot_data <- plot_data %>%
      distinct(ID_merged, .keep_all = TRUE)
  }
  a_gen_tbl <- function(pat, group, distn) {
    info <- as.data.frame(pat %>%
                            count(!!as.name(distn), !!as.name(group))) %>%
      na.omit()
    tbl <- reshape(info, idvar = distn, timevar = group, direction = 'wide', sep = '_') %>%
      replace(., is.na(.), 0) %>%
      mutate(All = rowSums(across(where(is.numeric))))
    return(tbl)
  }
  tbl <- a_gen_tbl(plot_data, group, distn)
  
  p <- ggplot(plot_data) +
    theme_bw() +
    geom_bar(aes(x = !!as.name(distn),fill = !!as.name(group)),
             stat = "count", position = "stack") +
    scale_fill_brewer(palette = "Set1")+
    labs(x = distn, y = 'Number of Subjects', title = 'Participant Distribution') +
    theme(plot.title = element_text(size = 12, face = 'bold', hjust = 0.5))
  
  p
}



review_complete <- function(res, check_cols) {
  df <- data.frame(res$analysis_data) # Assuming analysis_data is a list or dataframe within res
  
  if (!all(check_cols %in% names(df))) {
    stop("Please make sure input data is within the column")
  }
  
  complete_cases_df <- df %>% filter(complete.cases(select(., check_cols)))
  
  follow_ups_per_patient <- complete_cases_df %>%
    group_by(ID_merged) %>%
    summarise(NumberOfFollowUps = n(), .groups = 'drop') # Ensure group data is dropped after summarise
  
  plot <- ggplot(follow_ups_per_patient, aes(x = NumberOfFollowUps)) +
    geom_bar(stat = "count") + # Ensure that the 'stat' argument is correct for geom_bar
    theme_minimal() +
    labs(title = "Distribution of the Number of Visits for Complete Cases",
         x = "Number of Visits",
         y = "Frequency")
  
  return(list(plot = plot, complete_df = complete_cases_df))
}


#' Plot function for files used to merge
#'
#' This function generates a scatter plot for distribution of IDs across time, grouped by different files
#'
# 
# plot.ADMerge_res = function(res,
#                             distn, # extend ...
#                             group,
#                             baseline = FALSE,
#                             ...) {
#   ana_data = res$analysis_data
#   dict_src = res$dict_src
#   name_ID = na.omit(unique(unlist(strsplit(dict_src$ID_for_merge, ", "))))[1]
#   plot_data <- ana_data %>%
#     select(ID_merged, !!as.name(distn), !!as.name(group)) %>% 
#     mutate(!!as.name(group) := factor(!!as.name(group)))
#   if (baseline) {
#     plot_data <- plot_data %>%
#       distinct(ID_merged, .keep_all = TRUE)
#   }
#   a_gen_tbl <- function(pat, group, distn) {
#     info <- as.data.frame(pat %>%
#                             count(!!as.name(distn), !!as.name(group))) %>%
#       na.omit()
#     tbl <- reshape(info, idvar = distn, timevar = group, direction = 'wide', sep = '_') %>%
#       replace(., is.na(.), 0) %>%
#       mutate(All = rowSums(across(where(is.numeric))))
#     return(tbl)
#   }
#   tbl <- a_gen_tbl(plot_data, group, distn)
#   
#   p <- ggplot(plot_data) +
#     theme_bw() +
#     geom_bar(aes(x = !!as.name(distn),fill = !!as.name(group)),
#              stat = "count", position = "stack") +
#     scale_fill_brewer(palette = "Set1")+
#     labs(x = distn, y = 'Number of Subjects', title = 'Participant Distribution') +
#     theme(plot.title = element_text(size = 12, face = 'bold', hjust = 0.5))
#   
#   p
# }

# complet_case.ADMerge_res <- function(res,check_cols){
#   df = data.frame(df$analysis_data)


# plot.files_no_dropdown <- function(path, FILE_pattern = "\\.xlsx$|\\.xls$|\\.csv$", dict_src = NULL) {
#   files_list <- list.files(path, pattern = FILE_pattern)
#   
#   # Load each file into the global environment
#   for (file_name in files_list) {
#     dat <- suppressWarnings(read_by_type(file_name, path))
#     f_name <- gsub(FILE_pattern, "", file_name) # Clean file name
#     assign(f_name, dat, envir = .GlobalEnv)
#   }
#   
#   # Initialize an empty dataframe for the results
#   combined_data <- data.frame(ID = character(), DATE = character(), FILE = character())
#   
#   dat_list <- dict_src$file
#   
#   for (data in dat_list) {
#     idx <- grep(data, dict_src$file)
#     if (length(idx) > 0) {
#       ID_col <- dict_src$ID_for_merge[idx]
#       DATE_col <- dict_src$DATE_for_merge[idx]
#       
#       dat_name <- gsub(FILE_pattern, "", data)
#       dat_tem <- get(dat_name, envir = .GlobalEnv)
#       
#       if (ID_col %in% names(dat_tem) && DATE_col %in% names(dat_tem)) {
#         dat_tem <- dat_tem %>%
#           mutate(!!as.name(ID_col) := as.character(.[[ID_col]]),
#                  !!as.name(DATE_col) := case_when(
#                    stringr::str_detect(.[[DATE_col]], "\\d{1,2}/\\d{1,2}/\\d{4}") ~ dmy(.[[DATE_col]], quiet = TRUE),
#                    stringr::str_detect(.[[DATE_col]], "\\d{4}-\\d{1,2}-\\d{1,2}") ~ ymd(.[[DATE_col]], quiet = TRUE),
#                    TRUE ~ as.Date(NA)
#                  ),
#                  FILE = as.character(data)) %>%
#           select(ID = !!as.name(ID_col), DATE = !!as.name(DATE_col), FILE)
#         
#         # Combine with the previously collected data
#         combined_data <- rbind(combined_data, dat_tem)
#       }
#     }
#   }
#   
#   # Start plotting
#   
#   combined_data$DATE <- as.Date(combined_data$DATE)
#   
#   combined_data <- combined_data %>% mutate(color = as.factor(FILE))
#   
#   color_palette <- RColorBrewer::brewer.pal(length(unique(combined_data$color)), "Set1")
#   
#   color_map <- setNames(color_palette, levels(combined_data$color))
#   
#   combined_data <- combined_data %>% mutate(color_value = color_map[color])
#   
#   combined_data <- combined_data %>% mutate(hover_text = paste("File:", FILE))
#   
#   p <- plot_ly(data = combined_data, x = ~DATE, y = ~ID, type = 'scattergl', mode = 'markers',
#                hoverinfo = 'text', # Display the hover text when hovering
#                text = ~hover_text, # Set the text that appears on hover
#                marker = list(size = 10, opacity = 0.6, color = ~color_value))
#   
#   # Add a custom hover event to highlight the group (FILE)
#   p <- p %>% onRender("
# function(el) {
#   var plotlyGraph = document.getElementById(el.id);
#   
#   plotlyGraph.on('plotly_hover', function(data) {
#     // Find the index of the hovered data point
#     var hoverIndex = data.points[0].pointIndex;
#     console.log('Hover index data:', hoverIndex);
#     
#     // Get the trace and group information for the hovered data point
#     var traceIndex = data.points[0].curveNumber;
#     var groupValue = data.points[0].fullData.marker.color[hoverIndex];
#     console.log('groupValue:', groupValue);
#     
#     // Create an array to set opacities
#     var opacities = new Array(data.points[0].fullData.x.length).fill(0.1); // Start with all opacities at 0.1
#     
#     // Set the opacity of the points in the same group as the hovered point to 1 (highlight)
#     data.points[0].fullData.x.forEach(function(_, i) {
#       if(data.points[0].fullData.marker.color[i] === groupValue) {
#         opacities[i] = 1;
#       }
#     });
#     
#     // Restyle the plot with the updated opacities
#     Plotly.restyle(el.id, {'marker.opacity': [opacities]}, [traceIndex]);
#   });
#   
#   plotlyGraph.on('plotly_unhover', function(data) {
#     // Reset the opacity for all points when not hovering
#     var resetOpacities = new Array(data.points[0].fullData.x.length).fill(0.1); // Reset all opacities to 0.6
#     Plotly.restyle(el.id, {'marker.opacity': [resetOpacities]});
#   });
# }
# ")
#   
#   # Customize the layout if desired
#   p <- p %>% layout(title = 'ID over Time by File',
#                     xaxis = list(title = 'Time'),
#                     yaxis = list(title = 'ID'),
#                     legend = list(orientation = 'h', x = 0, y = -0.3, xanchor = 'left', yanchor = 'bottom'),
#                     hovermode = 'closest')
#   
#   
#   
#   return(p)
#   
# 
# }








